// SPDX-License-Identifier: MIT
pragma solidity ^0.8.21;

interface ISpotMarketProxy {
    error ImplementationIsSterile(address implementation);
    error NoChange();
    error NotAContract(address contr);
    error NotNominated(address addr);
    error Unauthorized(address addr);
    error UpgradeSimulationFailed();
    error ZeroAddress();
    event OwnerChanged(address oldOwner, address newOwner);
    event OwnerNominated(address newOwner);
    event Upgraded(address indexed self, address implementation);
    function acceptOwnership() external;
    function getImplementation() external view returns (address);
    function nominateNewOwner(address newNominatedOwner) external;
    function nominatedOwner() external view returns (address);
    function owner() external view returns (address);
    function renounceNomination() external;
    function simulateUpgradeTo(address newImplementation) external;
    function upgradeTo(address newImplementation) external;
    error FeatureUnavailable(bytes32 which);
    error InvalidMarketOwner();
    error InvalidSynthImplementation(uint256 synthImplementation);
    error InvalidTransactionTypeIndex(uint128 txnType);
    error MismatchAssociatedSystemKind(bytes32 expected, bytes32 actual);
    error MissingAssociatedSystem(bytes32 id);
    error OnlyMarketOwner(address marketOwner, address sender);
    error OverflowInt256ToUint256();
    event AssociatedSystemSet(bytes32 indexed kind, bytes32 indexed id, address proxy, address impl);
    event DecayRateUpdated(uint128 indexed marketId, uint256 rate);
    event MarketNominationRenounced(uint128 indexed marketId, address nominee);
    event MarketOwnerChanged(uint128 indexed marketId, address oldOwner, address newOwner);
    event MarketOwnerNominated(uint128 indexed marketId, address newOwner);
    event SynthImplementationSet(address synthImplementation);
    event SynthImplementationUpgraded(uint256 indexed synthMarketId, address indexed proxy, address implementation);
    event SynthPriceDataUpdated(uint256 indexed synthMarketId, bytes32 indexed buyFeedId, bytes32 indexed sellFeedId, uint256 strictStalenessTolerance);
    event SynthRegistered(uint256 indexed synthMarketId, address synthTokenAddress);
    event SynthetixSystemSet(address synthetix, address usdTokenAddress, address oracleManager);
    function acceptMarketOwnership(uint128 synthMarketId) external;
    function createSynth(string memory tokenName, string memory tokenSymbol, address synthOwner) external returns (uint128 synthMarketId);
    function getAssociatedSystem(bytes32 id) external view returns (address addr, bytes32 kind);
    function getMarketOwner(uint128 synthMarketId) external view returns (address marketOwner);
    function getNominatedMarketOwner(uint128 synthMarketId) external view returns (address marketOwner);
    function getPriceData(uint128 synthMarketId) external view returns (bytes32 buyFeedId, bytes32 sellFeedId, uint256 strictPriceStalenessTolerance);
    function getSynth(uint128 marketId) external view returns (address synthAddress);
    function getSynthImpl(uint128 marketId) external view returns (address implAddress);
    function indexPrice(uint128 marketId, uint128 transactionType, uint8 priceTolerance) external view returns (uint256 price);
    function initOrUpgradeNft(bytes32 id, string memory name, string memory symbol, string memory uri, address impl) external;
    function initOrUpgradeToken(bytes32 id, string memory name, string memory symbol, uint8 decimals, address impl) external;
    function minimumCredit(uint128 marketId) external view returns (uint256 lockedAmount);
    function name(uint128 marketId) external view returns (string memory marketName);
    function nominateMarketOwner(uint128 synthMarketId, address newNominatedOwner) external;
    function registerUnmanagedSystem(bytes32 id, address endpoint) external;
    function renounceMarketNomination(uint128 synthMarketId) external;
    function renounceMarketOwnership(uint128 synthMarketId) external;
    function reportedDebt(uint128 marketId) external view returns (uint256 reportedDebtAmount);
    function setDecayRate(uint128 marketId, uint256 rate) external;
    function setSynthImplementation(address synthImplementation) external;
    function setSynthetix(address synthetix) external;
    function supportsInterface(bytes4 interfaceId) external view returns (bool isSupported);
    function updatePriceData(uint128 synthMarketId, bytes32 buyFeedId, bytes32 sellFeedId, uint256 strictPriceStalenessTolerance) external;
    function upgradeSynthImpl(uint128 marketId) external;
    error ExceedsMaxSynthAmount(uint256 maxSynthAmount, uint256 synthAmountCharged);
    error ExceedsMaxUsdAmount(uint256 maxUsdAmount, uint256 usdAmountCharged);
    error InsufficientAmountReceived(uint256 expected, uint256 current);
    error InvalidMarket(uint128 marketId);
    error InvalidPrices();
    error OverflowUint256ToInt256();
    event SynthBought(uint256 indexed synthMarketId, uint256 synthReturned, OrderFees.Data fees, uint256 collectedFees, address referrer, uint256 price);
    event SynthSold(uint256 indexed synthMarketId, uint256 amountReturned, OrderFees.Data fees, uint256 collectedFees, address referrer, uint256 price);
    function buy(uint128 marketId, uint256 usdAmount, uint256 minAmountReceived, address referrer) external returns (uint256 synthAmount, OrderFees.Data memory fees);
    function buyExactIn(uint128 marketId, uint256 usdAmount, uint256 minAmountReceived, address referrer) external returns (uint256 synthAmount, OrderFees.Data memory fees);
    function buyExactOut(uint128 marketId, uint256 synthAmount, uint256 maxUsdAmount, address referrer) external returns (uint256 usdAmountCharged, OrderFees.Data memory fees);
    function getMarketSkew(uint128 marketId) external view returns (int256 marketSkew);
    function quoteBuyExactIn(uint128 marketId, uint256 usdAmount, uint8 stalenessTolerance) external view returns (uint256 synthAmount, OrderFees.Data memory fees);
    function quoteBuyExactOut(uint128 marketId, uint256 synthAmount, uint8 stalenessTolerance) external view returns (uint256 usdAmountCharged, OrderFees.Data memory fees);
    function quoteSellExactIn(uint128 marketId, uint256 synthAmount, uint8 stalenessTolerance) external view returns (uint256 returnAmount, OrderFees.Data memory fees);
    function quoteSellExactOut(uint128 marketId, uint256 usdAmount, uint8 stalenessTolerance) external view returns (uint256 synthToBurn, OrderFees.Data memory fees);
    function sell(uint128 marketId, uint256 synthAmount, uint256 minUsdAmount, address referrer) external returns (uint256 usdAmountReceived, OrderFees.Data memory fees);
    function sellExactIn(uint128 marketId, uint256 synthAmount, uint256 minAmountReceived, address referrer) external returns (uint256 returnAmount, OrderFees.Data memory fees);
    function sellExactOut(uint128 marketId, uint256 usdAmount, uint256 maxSynthAmount, address referrer) external returns (uint256 synthToBurn, OrderFees.Data memory fees);
    error IneligibleForCancellation(uint256 timestamp, uint256 expirationTime);
    error InsufficientSharesAmount(uint256 expected, uint256 actual);
    error InvalidAsyncTransactionType(uint8 transactionType);
    error InvalidClaim(uint256 asyncOrderId);
    error InvalidCommitmentAmount(uint256 minimumAmount, uint256 amount);
    error InvalidSettlementStrategy(uint256 settlementStrategyId);
    error OrderAlreadySettled(uint256 asyncOrderId, uint256 settledAt);
    event OrderCancelled(uint128 indexed marketId, uint128 indexed asyncOrderId, AsyncOrderClaim.Data asyncOrderClaim, address indexed sender);
    event OrderCommitted(uint128 indexed marketId, uint8 indexed orderType, uint256 amountProvided, uint128 asyncOrderId, address indexed sender, address referrer);
    function cancelOrder(uint128 marketId, uint128 asyncOrderId) external;
    function commitOrder(uint128 marketId, uint8 orderType, uint256 amountProvided, uint256 settlementStrategyId, uint256 minimumSettlementAmount, address referrer) external returns (AsyncOrderClaim.Data memory asyncOrderClaim);
    function getAsyncOrderClaim(uint128 marketId, uint128 asyncOrderId) external pure returns (AsyncOrderClaim.Data memory asyncOrderClaim);
    error InvalidSettlementStrategy(uint8 strategyType);
    error InvalidVerificationResponse();
    error MinimumSettlementAmountNotMet(uint256 minimum, uint256 actual);
    error OutsideSettlementWindow(uint256 timestamp, uint256 startTime, uint256 expirationTime);
    error OverflowUint256ToUint64();
    error SettlementStrategyNotFound(uint8 strategyType);
    event OrderSettled(uint128 indexed marketId, uint128 indexed asyncOrderId, uint256 finalOrderAmount, OrderFees.Data fees, uint256 collectedFees, address indexed settler, uint256 price, uint8 orderType);
    function settleOrder(uint128 marketId, uint128 asyncOrderId) external returns (uint256 finalOrderAmount, OrderFees.Data memory fees);
    error InvalidSettlementWindowDuration(uint256 duration);
    event SettlementStrategyAdded(uint128 indexed synthMarketId, uint256 indexed strategyId);
    event SettlementStrategySet(uint128 indexed synthMarketId, uint256 indexed strategyId, SettlementStrategy.Data strategy);
    function addSettlementStrategy(uint128 marketId, SettlementStrategy.Data memory strategy) external returns (uint256 strategyId);
    function getSettlementStrategy(uint128 marketId, uint256 strategyId) external view returns (SettlementStrategy.Data memory settlementStrategy);
    function setSettlementStrategy(uint128 marketId, uint256 strategyId, SettlementStrategy.Data memory strategy) external;
    function setSettlementStrategyEnabled(uint128 marketId, uint256 strategyId, bool enabled) external;
    error FailedTransfer(address from, address to, uint256 value);
    error InvalidCollateralType(address configuredCollateralType);
    error WrapperExceedsMaxAmount(uint256 maxWrappableAmount, uint256 currentSupply, uint256 amountToWrap);
    event SynthUnwrapped(uint256 indexed synthMarketId, uint256 amountUnwrapped, OrderFees.Data fees, uint256 feesCollected);
    event SynthWrapped(uint256 indexed synthMarketId, uint256 amountWrapped, OrderFees.Data fees, uint256 feesCollected);
    event WrapperSet(uint256 indexed synthMarketId, address indexed wrapCollateralType, uint256 maxWrappableAmount);
    function getWrapper(uint128 marketId) external view returns (address wrapCollateralType, uint256 maxWrappableAmount);
    function setWrapper(uint128 marketId, address wrapCollateralType, uint256 maxWrappableAmount) external;
    function unwrap(uint128 marketId, uint256 unwrapAmount, uint256 minAmountReceived) external returns (uint256 returnCollateralAmount, OrderFees.Data memory fees);
    function wrap(uint128 marketId, uint256 wrapAmount, uint256 minAmountReceived) external returns (uint256 amountToMint, OrderFees.Data memory fees);
    error InvalidCollateralLeverage(uint256);
    error InvalidFeeCollectorInterface(address invalidFeeCollector);
    error InvalidWrapperFees();
    event AsyncFixedFeeSet(uint256 indexed synthMarketId, uint256 asyncFixedFee);
    event AtomicFixedFeeSet(uint256 indexed synthMarketId, uint256 atomicFixedFee);
    event CollateralLeverageSet(uint256 indexed synthMarketId, uint256 collateralLeverage);
    event FeeCollectorSet(uint256 indexed synthMarketId, address feeCollector);
    event MarketSkewScaleSet(uint256 indexed synthMarketId, uint256 skewScale);
    event MarketUtilizationFeesSet(uint256 indexed synthMarketId, uint256 utilizationFeeRate);
    event ReferrerShareUpdated(uint128 indexed marketId, address referrer, uint256 sharePercentage);
    event TransactorFixedFeeSet(uint256 indexed synthMarketId, address transactor, uint256 fixedFeeAmount);
    event WrapperFeesSet(uint256 indexed synthMarketId, int256 wrapFee, int256 unwrapFee);
    function getCollateralLeverage(uint128 synthMarketId) external view returns (uint256 collateralLeverage);
    function getCustomTransactorFees(uint128 synthMarketId, address transactor) external view returns (uint256 fixedFeeAmount);
    function getFeeCollector(uint128 synthMarketId) external view returns (address feeCollector);
    function getMarketFees(uint128 synthMarketId) external view returns (uint256 atomicFixedFee, uint256 asyncFixedFee, int256 wrapFee, int256 unwrapFee);
    function getMarketSkewScale(uint128 synthMarketId) external view returns (uint256 skewScale);
    function getMarketUtilizationFees(uint128 synthMarketId) external view returns (uint256 utilizationFeeRate);
    function getReferrerShare(uint128 synthMarketId, address referrer) external view returns (uint256 sharePercentage);
    function setAsyncFixedFee(uint128 synthMarketId, uint256 asyncFixedFee) external;
    function setAtomicFixedFee(uint128 synthMarketId, uint256 atomicFixedFee) external;
    function setCollateralLeverage(uint128 synthMarketId, uint256 collateralLeverage) external;
    function setCustomTransactorFees(uint128 synthMarketId, address transactor, uint256 fixedFeeAmount) external;
    function setFeeCollector(uint128 synthMarketId, address feeCollector) external;
    function setMarketSkewScale(uint128 synthMarketId, uint256 skewScale) external;
    function setMarketUtilizationFees(uint128 synthMarketId, uint256 utilizationFeeRate) external;
    function setWrapperFees(uint128 synthMarketId, int256 wrapFee, int256 unwrapFee) external;
    function updateReferrerShare(uint128 synthMarketId, address referrer, uint256 sharePercentage) external;
    error ValueAlreadyInSet();
    error ValueNotInSet();
    event FeatureFlagAllowAllSet(bytes32 indexed feature, bool allowAll);
    event FeatureFlagAllowlistAdded(bytes32 indexed feature, address account);
    event FeatureFlagAllowlistRemoved(bytes32 indexed feature, address account);
    event FeatureFlagDeniersReset(bytes32 indexed feature, address[] deniers);
    event FeatureFlagDenyAllSet(bytes32 indexed feature, bool denyAll);
    function addToFeatureFlagAllowlist(bytes32 feature, address account) external;
    function getDeniers(bytes32 feature) external view returns (address[] memory);
    function getFeatureFlagAllowAll(bytes32 feature) external view returns (bool);
    function getFeatureFlagAllowlist(bytes32 feature) external view returns (address[] memory);
    function getFeatureFlagDenyAll(bytes32 feature) external view returns (bool);
    function isFeatureAllowed(bytes32 feature, address account) external view returns (bool);
    function removeFromFeatureFlagAllowlist(bytes32 feature, address account) external;
    function setDeniers(bytes32 feature, address[] memory deniers) external;
    function setFeatureFlagAllowAll(bytes32 feature, bool allowAll) external;
    function setFeatureFlagDenyAll(bytes32 feature, bool denyAll) external;
}

interface OrderFees {
    struct Data {
        uint256 fixedFees;
        uint256 utilizationFees;
        int256 skewFees;
        int256 wrapperFees;
    }
}

interface AsyncOrderClaim {
    struct Data {
        uint128 id;
        address owner;
        uint8 orderType;
        uint256 amountEscrowed;
        uint256 settlementStrategyId;
        uint256 commitmentTime;
        uint256 minimumSettlementAmount;
        uint256 settledAt;
        address referrer;
    }
}

interface SettlementStrategy {
    struct Data {
        uint8 strategyType;
        uint256 settlementDelay;
        uint256 settlementWindowDuration;
        address priceVerificationContract;
        bytes32 feedId;
        string url;
        uint256 settlementReward;
        uint256 priceDeviationTolerance;
        uint256 minimumUsdExchangeAmount;
        uint256 maxRoundingLoss;
        bool disabled;
    }
}
